<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="2.9" jmeter="3.0 r1743807">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="update" enabled="true">
      <stringProp name="TestPlan.comments">SELECT * FROM table_name WHERE column1 [ &lt;= | != | LIKE | NOT LIKE | IN | NOT IN ] value1 [AND | OR] column2 [...] value2 [...] ...</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="CHARLIST" elementType="Argument">
            <stringProp name="Argument.name">CHARLIST</stringProp>
            <stringProp name="Argument.value">&quot;abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="INTEGER" elementType="Argument">
            <stringProp name="Argument.name">INTEGER</stringProp>
            <stringProp name="Argument.value">0123456789</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="NUM_OF_TESTROWS" elementType="Argument">
            <stringProp name="Argument.name">NUM_OF_TESTROWS</stringProp>
            <stringProp name="Argument.value">${__P(datasize,10)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MACHINE" elementType="Argument">
            <stringProp name="Argument.name">MACHINE</stringProp>
            <stringProp name="Argument.value">txnl</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DBNAME" elementType="Argument">
            <stringProp name="Argument.name">DBNAME</stringProp>
            <stringProp name="Argument.value">shipment</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="INPUTGIVEN" elementType="Argument">
            <stringProp name="Argument.name">INPUTGIVEN</stringProp>
            <stringProp name="Argument.value">${__P(inputgiven,n)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="INPUTFILE" elementType="Argument">
            <stringProp name="Argument.name">INPUTFILE</stringProp>
            <stringProp name="Argument.value">${__P(inputfile,&quot;testCases/queryNReturnCols.csv&quot;)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="IGNORETABLES" elementType="Argument">
            <stringProp name="Argument.name">IGNORETABLES</stringProp>
            <stringProp name="Argument.value">&quot;tmp/ignoreTables.csv&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SELECT_FILE" elementType="Argument">
            <stringProp name="Argument.name">SELECT_FILE</stringProp>
            <stringProp name="Argument.value">&quot;tmp/selectStmt.sql&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SELECT_FILE_TXNL" elementType="Argument">
            <stringProp name="Argument.name">SELECT_FILE_TXNL</stringProp>
            <stringProp name="Argument.value">&quot;tmp/selectStmtTxnl.sql&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SELECT_FILE_SEC" elementType="Argument">
            <stringProp name="Argument.name">SELECT_FILE_SEC</stringProp>
            <stringProp name="Argument.value">&quot;tmp/selectStmtSec.sql&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="VSCHEMAFILE" elementType="Argument">
            <stringProp name="Argument.name">VSCHEMAFILE</stringProp>
            <stringProp name="Argument.value">&quot;shipmentVSchema.json&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="BIGINT_RANGE" elementType="Argument">
            <stringProp name="Argument.name">BIGINT_RANGE</stringProp>
            <stringProp name="Argument.value">10000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="INT_RANGE" elementType="Argument">
            <stringProp name="Argument.name">INT_RANGE</stringProp>
            <stringProp name="Argument.value">1000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="BIGINT_BIT_RANGE" elementType="Argument">
            <stringProp name="Argument.name">BIGINT_BIT_RANGE</stringProp>
            <stringProp name="Argument.value">63</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="BIT_RANGE" elementType="Argument">
            <stringProp name="Argument.name">BIT_RANGE</stringProp>
            <stringProp name="Argument.value">2</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="TINYINT_RANGE" elementType="Argument">
            <stringProp name="Argument.name">TINYINT_RANGE</stringProp>
            <stringProp name="Argument.value">256</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="INT_BIT_RANGE" elementType="Argument">
            <stringProp name="Argument.name">INT_BIT_RANGE</stringProp>
            <stringProp name="Argument.value">31</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MAX_STRING_LENGTH" elementType="Argument">
            <stringProp name="Argument.name">MAX_STRING_LENGTH</stringProp>
            <stringProp name="Argument.value">15</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="PREFIX_STRING" elementType="Argument">
            <stringProp name="Argument.name">PREFIX_STRING</stringProp>
            <stringProp name="Argument.value">&quot;TestData&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DATETIME_MIN_IST" elementType="Argument">
            <stringProp name="Argument.name">DATETIME_MIN_IST</stringProp>
            <stringProp name="Argument.value">&quot;1970-01-01 00:00:00&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DATETIME_MAX_IST" elementType="Argument">
            <stringProp name="Argument.name">DATETIME_MAX_IST</stringProp>
            <stringProp name="Argument.value">&quot;1980-01-01 23:59:59&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DATETIME_MIN_UTC" elementType="Argument">
            <stringProp name="Argument.name">DATETIME_MIN_UTC</stringProp>
            <stringProp name="Argument.value">&quot;1969-12-31 18:30:00&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DATETIME_MAX_UTC" elementType="Argument">
            <stringProp name="Argument.name">DATETIME_MAX_UTC</stringProp>
            <stringProp name="Argument.value">&quot;1980-01-01 18:29:59&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DATETIME_ACCU" elementType="Argument">
            <stringProp name="Argument.name">DATETIME_ACCU</stringProp>
            <stringProp name="Argument.value">1000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="IST_TO_UTC" elementType="Argument">
            <stringProp name="Argument.name">IST_TO_UTC</stringProp>
            <stringProp name="Argument.value">-19800000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="UTC_TO_IST" elementType="Argument">
            <stringProp name="Argument.name">UTC_TO_IST</stringProp>
            <stringProp name="Argument.value">19800000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="VINDEX" elementType="Argument">
            <stringProp name="Argument.name">VINDEX</stringProp>
            <stringProp name="Argument.value">&quot;vindex&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SEC_INDEX" elementType="Argument">
            <stringProp name="Argument.name">SEC_INDEX</stringProp>
            <stringProp name="Argument.value">&quot;secIndex&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="NON_INDEX" elementType="Argument">
            <stringProp name="Argument.name">NON_INDEX</stringProp>
            <stringProp name="Argument.value">&quot;nonIndex&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="PRIMARYKEY" elementType="Argument">
            <stringProp name="Argument.name">PRIMARYKEY</stringProp>
            <stringProp name="Argument.value">&quot;pk&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SHARDINGKEY" elementType="Argument">
            <stringProp name="Argument.name">SHARDINGKEY</stringProp>
            <stringProp name="Argument.value">&quot;sk&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="HOSTNAME_SECONDARY" elementType="Argument">
            <stringProp name="Argument.name">HOSTNAME_SECONDARY</stringProp>
            <stringProp name="Argument.value">ekart-tds-aesop2.nm.flipkart.com</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="HOSTNAME_TXNL" elementType="Argument">
            <stringProp name="Argument.name">HOSTNAME_TXNL</stringProp>
            <stringProp name="Argument.value">ekart-tds-0001.nm.flipkart.com</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DRIVER_CLASS" elementType="Argument">
            <stringProp name="Argument.name">DRIVER_CLASS</stringProp>
            <stringProp name="Argument.value">com.flipkart.polyglot.jdbc.PolyglotDriver</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="TESTCASE_SEPARATOR" elementType="Argument">
            <stringProp name="Argument.name">TESTCASE_SEPARATOR</stringProp>
            <stringProp name="Argument.value">&quot;;&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="PARAMETER_SEPARATOR" elementType="Argument">
            <stringProp name="Argument.name">PARAMETER_SEPARATOR</stringProp>
            <stringProp name="Argument.value">&quot;,&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SELECT_STAR" elementType="Argument">
            <stringProp name="Argument.name">SELECT_STAR</stringProp>
            <stringProp name="Argument.value">&quot;*&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_AND_CLAUSE" elementType="Argument">
            <stringProp name="Argument.name">SQL_AND_CLAUSE</stringProp>
            <stringProp name="Argument.value">&quot; and &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_WHERE_CLAUSE" elementType="Argument">
            <stringProp name="Argument.name">SQL_WHERE_CLAUSE</stringProp>
            <stringProp name="Argument.value">&quot; where &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_VALUES_CLAUSE" elementType="Argument">
            <stringProp name="Argument.name">SQL_VALUES_CLAUSE</stringProp>
            <stringProp name="Argument.value">&quot; values &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_SELECT" elementType="Argument">
            <stringProp name="Argument.name">SQL_SELECT</stringProp>
            <stringProp name="Argument.value">&quot; select &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_FROM_CLAUSE" elementType="Argument">
            <stringProp name="Argument.name">SQL_FROM_CLAUSE</stringProp>
            <stringProp name="Argument.value">&quot; from &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_INSERT" elementType="Argument">
            <stringProp name="Argument.name">SQL_INSERT</stringProp>
            <stringProp name="Argument.value">&quot; insert into &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="BRACKET_OPEN" elementType="Argument">
            <stringProp name="Argument.name">BRACKET_OPEN</stringProp>
            <stringProp name="Argument.value">&quot;(&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="BRACKET_CLOSE" elementType="Argument">
            <stringProp name="Argument.name">BRACKET_CLOSE</stringProp>
            <stringProp name="Argument.value">&quot;)&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="PREPARESTMT_SYMBOL" elementType="Argument">
            <stringProp name="Argument.name">PREPARESTMT_SYMBOL</stringProp>
            <stringProp name="Argument.value">&quot;?&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="DEREFERENCE" elementType="Argument">
            <stringProp name="Argument.name">DEREFERENCE</stringProp>
            <stringProp name="Argument.value">&quot;.&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="TESTCASE_FILE" elementType="Argument">
            <stringProp name="Argument.name">TESTCASE_FILE</stringProp>
            <stringProp name="Argument.value">${__P(testCaseFile,testCases/testCase5.csv)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="EQUALS" elementType="Argument">
            <stringProp name="Argument.name">EQUALS</stringProp>
            <stringProp name="Argument.value">&quot;=&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="TO_DATE_FUNC" elementType="Argument">
            <stringProp name="Argument.name">TO_DATE_FUNC</stringProp>
            <stringProp name="Argument.value">&quot;TO_DATE&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_QUOTE" elementType="Argument">
            <stringProp name="Argument.name">SQL_QUOTE</stringProp>
            <stringProp name="Argument.value">&quot;&apos;&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_DELETE" elementType="Argument">
            <stringProp name="Argument.name">SQL_DELETE</stringProp>
            <stringProp name="Argument.value">&quot; delete &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="TXNL" elementType="Argument">
            <stringProp name="Argument.name">TXNL</stringProp>
            <stringProp name="Argument.value">&quot;txnl&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SECONDARY" elementType="Argument">
            <stringProp name="Argument.name">SECONDARY</stringProp>
            <stringProp name="Argument.value">&quot;sec&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_BETWEEN_CLAUSE" elementType="Argument">
            <stringProp name="Argument.name">SQL_BETWEEN_CLAUSE</stringProp>
            <stringProp name="Argument.value">&quot; between &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_LIKE_CLAUSE" elementType="Argument">
            <stringProp name="Argument.name">SQL_LIKE_CLAUSE</stringProp>
            <stringProp name="Argument.value">&quot; like &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_IN_CLAUSE" elementType="Argument">
            <stringProp name="Argument.name">SQL_IN_CLAUSE</stringProp>
            <stringProp name="Argument.value">&quot; in &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_NOT_CLAUSE" elementType="Argument">
            <stringProp name="Argument.name">SQL_NOT_CLAUSE</stringProp>
            <stringProp name="Argument.value">&quot; not &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SQL_UPDATE" elementType="Argument">
            <stringProp name="Argument.name">SQL_UPDATE</stringProp>
            <stringProp name="Argument.value">&quot; update &quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="REGEX_WHITESPACE" elementType="Argument">
            <stringProp name="Argument.name">REGEX_WHITESPACE</stringProp>
            <stringProp name="Argument.value">&quot;\\s&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="IS_AUTOINCREMENT" elementType="Argument">
            <stringProp name="Argument.name">IS_AUTOINCREMENT</stringProp>
            <stringProp name="Argument.value">&quot;autoIncrement&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="IS_NULLABLE" elementType="Argument">
            <stringProp name="Argument.name">IS_NULLABLE</stringProp>
            <stringProp name="Argument.value">&quot;nullable&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="COLUMN_DEF" elementType="Argument">
            <stringProp name="Argument.name">COLUMN_DEF</stringProp>
            <stringProp name="Argument.value">&quot;default&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="VINDEX_UNIQUE" elementType="Argument">
            <stringProp name="Argument.name">VINDEX_UNIQUE</stringProp>
            <stringProp name="Argument.value">&quot;vindexUnique&quot;</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="Master TDS" enabled="true">
        <stringProp name="dataSource">master</stringProp>
        <stringProp name="poolMax">0</stringProp>
        <stringProp name="timeout">10000</stringProp>
        <stringProp name="trimInterval">60000</stringProp>
        <boolProp name="autocommit">false</boolProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <boolProp name="keepAlive">true</boolProp>
        <stringProp name="connectionAge">5000</stringProp>
        <stringProp name="checkQuery">show tables</stringProp>
        <stringProp name="dbUrl">jdbc:polyglot://txnstore:${HOSTNAME_TXNL}:15991@archivalstore:${HOSTNAME_SECONDARY}:2181:hbase/shipment/shipment?dataStoreType=txnl&amp;TABLET_TYPE=master</stringProp>
        <stringProp name="driver">${DRIVER_CLASS}</stringProp>
        <stringProp name="username"></stringProp>
        <stringProp name="password"></stringProp>
        <stringProp name="TestPlan.comments">Connect configuration for local TDS and specific to MASTER MySQL instance</stringProp>
      </JDBCDataSource>
      <hashTree/>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="Slave TDS" enabled="true">
        <stringProp name="dataSource">slave</stringProp>
        <stringProp name="poolMax">0</stringProp>
        <stringProp name="timeout">10000</stringProp>
        <stringProp name="trimInterval">60000</stringProp>
        <boolProp name="autocommit">false</boolProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <boolProp name="keepAlive">true</boolProp>
        <stringProp name="connectionAge">5000</stringProp>
        <stringProp name="checkQuery">show tables</stringProp>
        <stringProp name="dbUrl">jdbc:polyglot://txnstore:${HOSTNAME_TXNL}:15991@archivalstore:${HOSTNAME_SECONDARY}:2181:hbase/shipment/shipment?dataStoreType=txnl&amp;TABLET_TYPE=replica</stringProp>
        <stringProp name="driver">${DRIVER_CLASS}</stringProp>
        <stringProp name="username"></stringProp>
        <stringProp name="password"></stringProp>
        <stringProp name="TestPlan.comments">Connect configuration for local TDS and specific to MASTER MySQL instance</stringProp>
      </JDBCDataSource>
      <hashTree/>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="Transactional Data Store" enabled="true">
        <stringProp name="dataSource">txnl</stringProp>
        <stringProp name="poolMax">0</stringProp>
        <stringProp name="timeout">10000</stringProp>
        <stringProp name="trimInterval">60000</stringProp>
        <boolProp name="autocommit">true</boolProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <boolProp name="keepAlive">true</boolProp>
        <stringProp name="connectionAge">5000</stringProp>
        <stringProp name="checkQuery">show tables</stringProp>
        <stringProp name="dbUrl">jdbc:polyglot://txnstore:${HOSTNAME_TXNL}:15991@archivalstore:${HOSTNAME_SECONDARY}:2181:hbase/shipment/shipment?dataStoreType=txnl</stringProp>
        <stringProp name="driver">${DRIVER_CLASS}</stringProp>
        <stringProp name="username"></stringProp>
        <stringProp name="password"></stringProp>
        <stringProp name="TestPlan.comments">Connect configuration for local TDS</stringProp>
      </JDBCDataSource>
      <hashTree/>
      <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="Secondary Data Store" enabled="true">
        <stringProp name="dataSource">sec</stringProp>
        <stringProp name="poolMax">0</stringProp>
        <stringProp name="timeout">10000</stringProp>
        <stringProp name="trimInterval">60000</stringProp>
        <boolProp name="autocommit">true</boolProp>
        <stringProp name="transactionIsolation">DEFAULT</stringProp>
        <boolProp name="keepAlive">true</boolProp>
        <stringProp name="connectionAge">5000</stringProp>
        <stringProp name="checkQuery">select * from dummy</stringProp>
        <stringProp name="dbUrl">jdbc:polyglot://txnstore:${HOSTNAME_TXNL}:15991@archivalstore:${HOSTNAME_SECONDARY}:2181:hbase/shipment/shipment?dataStoreType=archival</stringProp>
        <stringProp name="driver">${DRIVER_CLASS}</stringProp>
        <stringProp name="username"></stringProp>
        <stringProp name="password"></stringProp>
        <stringProp name="TestPlan.comments">Connect configuration for local TDS</stringProp>
      </JDBCDataSource>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="prepPhase" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1465147238000</longProp>
        <longProp name="ThreadGroup.end_time">1465147238000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="init" enabled="true">
          <stringProp name="TestPlan.comments">Initialises the object in which the meta data of all the tables will be stored:  </stringProp>
          <stringProp name="BeanShellSampler.query">import java.sql.*;
import java.util.*;
import org.apache.jmeter.protocol.jdbc.config.DataSourceElement;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

bsh.shared.tableMetaData = new HashMap();
bsh.shared.insertResult = new HashMap();
bsh.shared.colNameList = new HashMap();
bsh.shared.queryValues = new ArrayList();
bsh.shared.ignoreTables = new ArrayList();
bsh.shared.ignoreColumns = new HashMap();
bsh.shared.ignoreTables = new ArrayList();
bsh.shared.autoIncrement = new HashMap();
/*
 * Initialising ColumnTypes
 */
colTypes = new ArrayList();
colTypes.add(${VINDEX});
colTypes.add(${SEC_INDEX});
colTypes.add(${NON_INDEX});
colTypes.add(${PRIMARYKEY});
colTypes.add(${SHARDINGKEY});
bsh.shared.colTypes = colTypes;

br = new BufferedReader(new FileReader(${IGNORETABLES}));
while ((line = br.readLine()) != null) {
	bsh.shared.ignoreTables.add(line);	
}</stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="vschemaExtractor" enabled="true">
          <stringProp name="BeanShellSampler.query">import org.json.simple.*;
import org.json.simple.parser.JSONParser;

/*
 * Sharing Key Index Type ArrayList
 */
shardingKeyIndexType = new ArrayList();
shardingKeyIndexType.add(&quot;hash&quot;);
shardingKeyIndexType.add(&quot;binarymd5&quot;);
shardingKeyIndexType.add(&quot;unicodeloosemd5&quot;);

/*
 * VIndexUnique Type ArrayList
 */
vindexUniqueType = new ArrayList();
vindexUniqueType.add(&quot;lookup_hash_unique&quot;);

String tableName = &quot;&quot;;
JSONParser parser = new JSONParser();
Object obj = parser.parse(new FileReader(${VSCHEMAFILE}));
JSONObject jsonObject = (JSONObject) obj;
JSONObject shardingKey = new JSONObject();

vindex = new HashMap();
vindexUnique = new HashMap();

boolean shardedStatus = jsonObject.get(&quot;sharded&quot;);
JSONObject tables = jsonObject.get(&quot;tables&quot;);
JSONObject vindexes = jsonObject.get(&quot;vindexes&quot;);
Iterator keys = tables.keySet().iterator();

getColumnVindexes(JSONObject tableDetails){
	vindex.put(tableName, new ArrayList());
	for(Object tableObj: tableDetails.get(&quot;column_vindexes&quot;)){
//		System.out.println(&quot;TableName &quot; + vindexes.get(obj.get(&quot;name&quot;)));
		String type = vindexes.get(tableObj.get(&quot;name&quot;)).get(&quot;type&quot;);
		if(shardingKeyIndexType.contains(type)){
//			System.out.println(&quot;TableName&quot; + vindexes.get(obj.get(&quot;name&quot;)));
			shardingKey.put(tableName, tableObj.get(&quot;column&quot;));
		}
		else{
			vindex.get(tableName).add(tableObj.get(&quot;column&quot;));
		}
    }
    
}

getColumnUniqueVindexes(JSONObject tableDetails){
	vindexUnique.put(tableName, new ArrayList());
	for(Object tableObj: tableDetails.get(&quot;column_vindexes&quot;)){
//		System.out.println(&quot;TableName &quot; + vindexes.get(obj.get(&quot;name&quot;)));
		String type = vindexes.get(tableObj.get(&quot;name&quot;)).get(&quot;type&quot;);
		if(vindexUniqueType.contains(type)){
			vindexUnique.get(tableName).add(tableObj.get(&quot;column&quot;));
		}
	}
}

getAutoIncrement(JSONObject tableDetails){
	/*
	 * Written with the assumption that at max only one auto_increment column will be defined
	 */
	 try{
	 	String colName = tableDetails.get(&quot;auto_increment&quot;).get(&quot;column&quot;);
	 	hashSet = new HashSet();
	 	hashSet.add(colName);
	 	bsh.shared.autoIncrement.put(tableName, hashSet);
	 }
	 catch(Exception e){
		hashSet = new HashSet();
	 	bsh.shared.autoIncrement.put(tableName, hashSet);
	 }

}

getValues(String tableName){
    	getColumnVindexes(tables.get(tableName));
  	getAutoIncrement(tables.get(tableName));
	getColumnUniqueVindexes(tables.get(tableName));	
}

while(keys.hasNext()) {
	tableName = (String)keys.next();
	if(bsh.shared.ignoreTables.contains(tableName)){
		continue;
	}
	getValues(tableName);
}

bsh.shared.vindex = vindex;
bsh.shared.shardingKey = shardingKey;
bsh.shared.vindexUnique = vindexUnique;
System.out.println(&quot;sk &quot; + shardingKey);
System.out.println(&quot;vindex &quot; + vindex);
System.out.println(&quot;vindexUnique &quot; + vindexUnique);
System.out.println(&quot;autoIncrement &quot; + bsh.shared.autoIncrement);

//System.out.println(&quot;ShardedStatus: &quot; + shardedStatus);
//System.out.println(&quot;Tables: &quot; + tables);</stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="queryColsReturnCols" enabled="true">
          <stringProp name="BeanShellSampler.query">/*
 * Query Columns: Columns on which where clause will be generated. 
 * Either specify the columns on which query is to be generated or let the code decide randomly  
 * Format: TableName ; QueryColumns; ReturnCols
 * 	TableName: Name of the table
 * 	QueryColumns: Name of the columns on which query will be generated. Delimited by comma(,)
 * 	ReturnColumns: Columns that you want to be returned.
 * 			 
 */
try{
	if(vars.get(&quot;INPUTGIVEN&quot;).equals(&quot;n&quot;)){
	fw = new FileWriter(${INPUTFILE}, false);
	bw = new BufferedWriter(fw);
	out = new PrintWriter(bw);
	Random rand = new Random();
	for(String tableName: bsh.shared.shardingKey.keySet()){
		String queryCols = &quot;&quot;;

		if(rand.nextInt(2) == 1){
			queryCols = queryCols + bsh.shared.shardingKey.get(tableName) + ${PARAMETER_SEPARATOR};	
		}
		
		if(bsh.shared.vindex.get(tableName) != null){
			int numOfQueryCols = rand.nextInt(bsh.shared.vindex.get(tableName).size() + 1);
			queryColsArray = new ArrayList(bsh.shared.vindex.get(tableName));
			Collections.shuffle(queryColsArray);

			for(String col: queryColsArray.subList(0, numOfQueryCols)){
				queryCols = queryCols + col + ${PARAMETER_SEPARATOR};
			}
		}
		if(queryCols.length() &gt; 0){
			queryCols = queryCols.substring(0, queryCols.length() - 1);
		}

		out.println(tableName + ${TESTCASE_SEPARATOR} + queryCols + ${TESTCASE_SEPARATOR} + ${SELECT_STAR});
	}
	out.close();
}
}
catch(Exception e){
	IsSuccess = false;
	System.out.println(e);
}</stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="extractMetaData" enabled="true">
          <stringProp name="TestPlan.comments">Initialises the object in which the meta data of all the tables will be stored:  </stringProp>
          <stringProp name="BeanShellSampler.query">import java.sql.*;
import java.util.*;
import org.apache.jmeter.protocol.jdbc.config.DataSourceElement;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
Random rand = new Random();
String tableName = &quot;&quot;;
Connection conn;

getColumnAttributes(ResultSet rs){
	attrLevel = new HashMap();
	attrLevel.put(&quot;Type&quot;, rs.getString(&quot;TYPE_NAME&quot;));
	attrLevel.put(${IS_NULLABLE}, rs.getString(&quot;IS_NULLABLE&quot;));
	attrLevel.put(${COLUMN_DEF}, rs.getString(&quot;COLUMN_DEF&quot;));
	attrLevel.put(&quot;Length&quot;, rs.getInt(&quot;COLUMN_SIZE&quot;));
	attrLevel.put(${IS_AUTOINCREMENT}, rs.getString(&quot;IS_AUTOINCREMENT&quot;));
	attrLevel.put(&quot;ColumnNumber&quot;, rs.getInt(&quot;ORDINAL_POSITION&quot;));
	return attrLevel;
}

generateColNameList(int colCount, HashMap colLevel){
	colNameList = new ArrayList(colCount);
	for(int i=0; i&lt;colCount;i++){
		colNameList.add(null);
	}
	for(String colName: colLevel.keySet()){
		colNameList.set(colLevel.get(colName).get(&quot;ColumnNumber&quot;) - 1, colName);
	}
	return colNameList;
}

getSecondaryIndexes(ResultSet rsSecIndex){
	secIndex = new ArrayList();
	while(rsSecIndex.next()){
		if(rsSecIndex.getString(&quot;INDEX_NAME&quot;).equals(&quot;PRIMARY&quot;)){
			continue;
		}
		else{
			secIndex.add(rsSecIndex.getString(&quot;COLUMN_NAME&quot;));
		}
	}
	System.out.println(&quot;secIndex&quot;+ secIndex);
	return secIndex;
}

getNonIndexes(ArrayList pk, ArrayList colNameList, ArrayList secIndex){
	nonIndex = new ArrayList();
	for(String colName: colNameList){
		if(pk.contains(colName) || secIndex.contains(colName) || bsh.shared.vindex.get(tableName).contains(colName) || bsh.shared.shardingKey.get(tableName).equals(colName)){
			continue;
		}
		else{
			nonIndex.add(colName);
		}
	}
	return nonIndex;
}


getPrimaryKeys(ResultSet rspk){
	pk = new ArrayList();
	while(rspk.next()){
		try{
			pk.set(rspk.getInt(&quot;KEY_SEQ&quot;) - 1, rspk.getString(&quot;COLUMN_NAME&quot;));	
		}
		catch(IndexOutOfBoundsException e){
			for(int i=pk.size(); i&lt;rspk.getInt(&quot;KEY_SEQ&quot;); i++){
				pk.add(null);
			}
			pk.set(rspk.getInt(&quot;KEY_SEQ&quot;) - 1, rspk.getString(&quot;COLUMN_NAME&quot;));
			//System.out.println(&quot;Error: &quot; + e.getMessage());
		}
		catch(Exception e){
			System.out.println(&quot;Error: &quot; + e.getMessage());
		}
	}
	return pk;
}

getQueryColumns(String[] content){
	queryCols = new ArrayList();
	if(content[1].equals(&quot;&quot;)){
	}
	else{
		queryCols.addAll(Arrays.asList(content[1].split(${PARAMETER_SEPARATOR})));
	}
	return queryCols;
}

getReturnColumns(String[] content, ArrayList colNameList, int colCount){
	returnCols = new ArrayList();
	if(content[2].equals(${SELECT_STAR})){
		returnCols.addAll(bsh.shared.colNameList.get(tableName));
	}
	else{
		returnCols.addAll(Arrays.asList(content[2].split(${PARAMETER_SEPARATOR})));
	}
	return returnCols;
}

printResultSet(ResultSet rs){
	ResultSetMetaData rsmd = rs.getMetaData();
	int colCount = rsmd.getColumnCount();
	while(rs.next()){
		for (int i = 1; i &lt;= colCount; i++) {
	        if (i &gt; 1) System.out.print(&quot;,  &quot;);
	        System.out.print(rsmd.getColumnName(i) + &quot; &quot; + rs.getString(i));
	
	    }
	        System.out.println(&quot;\n&quot;);
	}
}

try{
	BufferedReader br = null;
	String line = &quot;&quot;;
	br = new BufferedReader(new FileReader(${INPUTFILE}));
	conn = DataSourceElement.getConnection(vars.get(&quot;MACHINE&quot;));
	System.out.println(&quot;Connection established!&quot;);
	
	DatabaseMetaData dbmd = conn.getMetaData();

	while ((line = br.readLine()) != null) {
		System.out.println(line);
		String[] content = line.split(${TESTCASE_SEPARATOR});
		tableName = content[0];
		ResultSet rs = dbmd.getColumns(vars.get(&quot;DBNAME&quot;), null, tableName, null);
		tableMetaData = bsh.shared.tableMetaData;
		colLevel = new HashMap();
		int colCount = 0;	

//		printResultSet(rs);	
		System.out.println(&quot;--------------------&quot;+tableName+ &quot;--------------------&quot;);
		
		while(rs.next()){

//Always declare new HashMap else use remove() method of hashMap. Because if clear() method is used then the element last added
//will get copied as many times as the number of elements in colList due to addition of reference in the colList in add() method. 
			HashMap attrLevel = getColumnAttributes(rs);
			colLevel.put(rs.getString(&quot;COLUMN_NAME&quot;), attrLevel);	
			colCount++;
		}
		
		tableLevel = new HashMap();
		tableLevel.put(&quot;colDetails&quot;,colLevel);
		tableLevel.put(${SHARDINGKEY}, bsh.shared.shardingKey.get(tableName));
		tableLevel.put(&quot;colCount&quot;, colCount);

		colNameList = generateColNameList(colCount, colLevel);
		bsh.shared.colNameList.put(tableName, colNameList);

		ResultSet rspk = dbmd.getPrimaryKeys(vars.get(&quot;DBNAME&quot;), null, tableName);		
//		printResultSet(rspk);

		pk = getPrimaryKeys(rspk);
		tableLevel.put(${PRIMARYKEY}, pk);

		ArrayList queryCols = getQueryColumns(content);
		tableLevel.put(&quot;QueryColumns&quot;, queryCols);

		ArrayList returnCols = getReturnColumns(content, colNameList, colCount); 
		tableLevel.put(&quot;ReturnColumns&quot;, returnCols);

		ResultSet rsSecIndex = dbmd.getIndexInfo(vars.get(&quot;DBNAME&quot;), null, tableName, false, false);
		secIndex = getSecondaryIndexes(rsSecIndex);
		tableLevel.put(${SEC_INDEX}, secIndex);

		nonIndex = getNonIndexes(pk, colNameList, secIndex);
		tableLevel.put(${NON_INDEX}, nonIndex);
		
		tableMetaData.put(tableName,tableLevel);	
		bsh.shared.tableMetaData = tableMetaData;
	}

}
catch(Exception e){
	System.out.println(e);
	IsSuccess=false;
}
finally{
	conn.close();
}
System.out.println(&quot;Connection closed!&quot;);
System.out.println(&quot;tableMetaData &quot; + bsh.shared.tableMetaData);
System.out.println(&quot;colNameList &quot; + bsh.shared.colNameList);</stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="insert" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1464357186000</longProp>
        <longProp name="ThreadGroup.end_time">1464357186000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="generateSelectStatement" enabled="true">
          <stringProp name="BeanShellSampler.query">fw = new FileWriter(${SELECT_FILE}, false);
bw = new BufferedWriter(fw);
out = new PrintWriter(bw);

String tableName = &quot;&quot;;

genLineStart(ArrayList returnCols){
	String initial = &quot;&quot;;

	if(returnCols.size() == bsh.shared.tableMetaData.get(tableName).get(&quot;colCount&quot;)){
		initial = ${SQL_SELECT} + ${SELECT_STAR} + ${SQL_FROM_CLAUSE} + vars.get(&quot;DBNAME&quot;) + ${DEREFERENCE} + tableName;
	}
	else{
		String temp = &quot;&quot;;
		for(String col : returnCols){
			temp = temp + col + ${PARAMETER_SEPARATOR};
		}
		temp = temp.substring(0, temp.length() - ${PARAMETER_SEPARATOR}.length());
		initial = ${SQL_SELECT} +  temp + ${SQL_FROM_CLAUSE} + vars.get(&quot;DBNAME&quot;) + ${DEREFERENCE} + tableName + &quot; &quot;;
	}
	return tableName + ${TESTCASE_SEPARATOR} + initial;
}

for(String tN: bsh.shared.tableMetaData.keySet()){
	tableName = tN;
	returnCols = bsh.shared.tableMetaData.get(tableName).get(&quot;ReturnColumns&quot;);
	String initial = genLineStart(returnCols);
	out.println(initial);
}

out.close();
bw.close();
</stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">true</boolProp>
          <intProp name="LoopController.loops">-1</intProp>
        </LoopController>
        <hashTree>
          <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data Set Config" enabled="true">
            <stringProp name="delimiter">\n</stringProp>
            <stringProp name="fileEncoding"></stringProp>
            <stringProp name="filename">${TESTCASE_FILE}</stringProp>
            <boolProp name="quotedData">false</boolProp>
            <boolProp name="recycle">false</boolProp>
            <stringProp name="shareMode">shareMode.all</stringProp>
            <boolProp name="stopThread">true</boolProp>
            <stringProp name="variableNames">line</stringProp>
          </CSVDataSet>
          <hashTree/>
          <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="insertUsingPreparedStatement" enabled="true">
            <stringProp name="BeanShellSampler.query">import java.sql.*;
import java.math.*;
import java.lang.Math.*;
import org.apache.jmeter.protocol.jdbc.config.DataSourceElement;
System.out.println(&quot;--------------------\nInsert Phase\n--------------------\n&quot;);
Random rand = new Random();
String tableName = &quot;&quot;;
randomString(Integer length){
	StringBuffer randStr = new StringBuffer();
    	for(int j=0; j&lt;length; j++)
    	{
    		int charListLength = ${CHARLIST}.length();	
        	int number = rand.nextInt(charListLength);
         	char ch = ${CHARLIST}.charAt(number);
         	randStr.append(ch);
    	}
    	return randStr;
}
randomTimestamp(){
    long offset = Timestamp.valueOf(${DATETIME_MIN_IST}).getTime();
    long end = Timestamp.valueOf(${DATETIME_MAX_IST}).getTime();
    long diff = end - offset + 1;
    
    //Divided and Multiplied by 1000 to prevent generation of MILLISECONDS
	Timestamp rand = new Timestamp(((offset + (long)(Math.random() * diff))/${DATETIME_ACCU})*${DATETIME_ACCU});
//	Timestamp rand = new Timestamp(offset + (long)(Math.random() * diff));
    return rand;
}
randomParameter(PreparedStatement stmt, String type, Integer length, Integer place){
//	System.out.printf(&quot;Arguments: %s %s %s %s&quot;,stmt, type, length, place);
	try{
	switch(type){
     	case &quot;BIGINT&quot;:
            //strconv.ParseInt used at the backend. Hence max value of int can be 2^63 - 1
			Integer b = rand.nextInt(${BIGINT_RANGE});
			stmt.setInt(place, b);
//			BigInteger b = new BigInteger(63, rand);
//			stmt.setLong(place, b.longValue());
//			long b = b.longValue();
			return b.toString();
		case &quot;INT&quot;:
			Integer b = rand.nextInt(${INT_RANGE});
			stmt.setInt(place, b);
//			BigInteger b = new BigInteger(31, rand);
//			stmt.setLong(place, b.longValue());
//			long b = b.longValue();
			return b.toString();
		case &quot;VARCHAR&quot;:
			if((length - ${PREFIX_STRING}.length()) &lt; 0){
				System.out.println(&quot;VARCHAR length too short! Change the prefix string&quot;);
			}
        	  	String str = ${PREFIX_STRING} + randomString(length - ${PREFIX_STRING}.length()).toString();
        	  	stmt.setString(place, str);
            	return (str.toString());
        	case &quot;TINYINT&quot;:
        		Integer b = rand.nextInt(${TINYINT_RANGE});
        	  	stmt.setInt(place, b);
            	return b.toString();
        	case &quot;BIT&quot;:
        	  	Integer b = rand.nextInt(${BIT_RANGE});
        	  	stmt.setInt(place, b);
            	return b.toString();
        	case &quot;DATETIME&quot;:
            	Timestamp tmsp = randomTimestamp();
            	stmt.setTimestamp(place, tmsp);
            	return tmsp.toString();
        	default:
            	return &quot;Hi&quot;;
    }
    }
    catch(Exception e){
    	System.out.println(e);
    }
}

addRowInInsertResult(HashMap insertTableLevel, ArrayList rowKey, ArrayList rowData){
	if(insertTableLevel.containsKey(rowKey)){
	   	insertTableLevel.get(rowKey).add(rowData);
	}
	else{
		ArrayList temp = new ArrayList();
		insertTableLevel.put(rowKey, temp);
		insertTableLevel.get(rowKey).add(rowData);
	}
}

generateSQL(PreparedStatement stmt, HashMap tableDetails, HashMap insertTableLevel, HashSet ignoreColumns){
	HashMap cols = tableDetails.get(&quot;colDetails&quot;);
	
	String key = null;
	String colValue = null;
	ArrayList colNameList = bsh.shared.colNameList.get(tableName);
	ArrayList insertColumnSequence = tableDetails.get(&quot;InsertColumnSequence&quot;);
//	System.out.println(&quot;ColNameList: &quot; + cols);
	rowKey = new ArrayList();
	rowData = new ArrayList();
	for(int i=0; i&lt;(tableDetails.get(&quot;colCount&quot;) - ignoreColumns.size()); i++){
	   rowData.add(null);
	}

	int place = 1;
	for(int i=0; i&lt;colNameList.size(); i++){
		colName = colNameList.get(i);
		if(ignoreColumns.contains(colName)){
			continue;
		}
		colValue = randomParameter(stmt, cols.get(colName).get(&quot;Type&quot;), ${MAX_STRING_LENGTH}, place);
		rowData.set(place - 1, colValue);
		place++;
	}

	/*for(Map.Entry col: cols.entrySet()){
		colName = col.getKey();
		colValue =  randomParameter(stmt, col.getValue().get(&quot;Type&quot;), ${MAX_STRING_LENGTH}, colNameList.indexOf(colName) + 1);
		rowData.set(colNameList.indexOf(colName), colValue);
	 }*/ 

	addRowInInsertResult(insertTableLevel, rowKey, rowData);
	return stmt;
}

prepareStmtSkeleton(ArrayList colNames, HashSet ignoreColumns){
	statement = new StringBuilder(${SQL_INSERT});
	statement.append(tableName);
	statement.append(${BRACKET_OPEN});
	clause = new StringBuilder(${SQL_VALUES_CLAUSE});
	clause.append(${BRACKET_OPEN});

	for(String colName: colNames){
		if(ignoreColumns.contains(colName)){
			continue;
		}
		statement.append(colName + ${PARAMETER_SEPARATOR});
		clause.append(${PREPARESTMT_SYMBOL} + ${PARAMETER_SEPARATOR});
	}
	if(colNames.size() &gt; 0){
		statement = statement.deleteCharAt(statement.length() - ${PARAMETER_SEPARATOR}.length());
		clause = clause.deleteCharAt(clause.length() - ${PARAMETER_SEPARATOR}.length());
		statement.append(${BRACKET_CLOSE});
		clause.append(${BRACKET_CLOSE});
	}
	statement.append(clause.toString());
	return statement.toString();
}

getIgnoreColumns(HashMap colLevel, ArrayList content){
	ignoreColumns = new HashSet();
	if(content.contains(${IS_AUTOINCREMENT})){
		for(String colName: bsh.shared.autoIncrement.get(tableName)){
			ignoreColumns.add(colName);	
		}
	}
	for(String colName: colLevel.keySet()){
		if(content.contains(${IS_NULLABLE}) &amp;&amp; colLevel.get(colName).get(${IS_NULLABLE}).equals(&quot;YES&quot;)){
			ignoreColumns.add(colName);	
			continue;
		}
		if(content.contains(${IS_AUTOINCREMENT}) &amp;&amp; colLevel.get(colName).get(${IS_AUTOINCREMENT}).equals(&quot;YES&quot;)){
			ignoreColumns.add(colName);	
			continue;
		}
		if(content.contains(${COLUMN_DEF}) &amp;&amp; !(colLevel.get(colName).get(${COLUMN_DEF}) == null)){
			ignoreColumns.add(colName);	
		}
	}
	return ignoreColumns;
}

getInsertColumnSequence(HashSet ignoreColumns, ArrayList colNameList){
	insertColList = new ArrayList();
	for(String colName: colNameList){
		if(ignoreColumns.contains(colName)){
			continue; 
		}
		insertColList.add(colName);
	}
	return insertColList;
}

Connection conn = DataSourceElement.getConnection(vars.get(&quot;MACHINE&quot;));
PreparedStatement stmt = null;

String line = &quot;&quot;;
int count = 0;

for(String tN: bsh.shared.tableMetaData.keySet()){
	tableName = tN;
	String line = &quot;&quot;;
	content = new ArrayList();
	System.out.println(&quot;-----------&quot; + tableName + &quot;-----------&quot;);

	ignoreColumns = getIgnoreColumns(bsh.shared.tableMetaData.get(tableName).get(&quot;colDetails&quot;), content);
	insertColNameList = getInsertColumnSequence(ignoreColumns, bsh.shared.colNameList.get(tableName)); 
	bsh.shared.tableMetaData.get(tableName).put(&quot;InsertColumnSequence&quot;, insertColNameList);
	
	String sql = prepareStmtSkeleton(bsh.shared.colNameList.get(tableName), ignoreColumns);
	stmt=conn.prepareStatement(sql);
//	System.out.println(sql);

	bsh.shared.insertResult.put(tableName, new HashMap());
	for(int i=0; i&lt; 2*${NUM_OF_TESTROWS}; i++){
		insertTableLevel = bsh.shared.insertResult.get(tableName);
		stmt = generateSQL(stmt, bsh.shared.tableMetaData.get(tableName), insertTableLevel, ignoreColumns);
		bsh.shared.insertResult.put(tableName, insertTableLevel);
//			System.out.println(&quot;Hi insertTableLevel &quot; + insertTableLevel);
		try{
				stmt.executeUpdate();
//			     System.out.println(&quot;Row &quot;+ i + &quot;: Inserted Successfully!&quot;);
		}
		catch (SQLException e){
			System.out.println(&quot;Row &quot;+ i + &quot;: Insert Failed!&quot;);			
			System.out.println(&quot;Check the log for error&quot;);
			log.error(e.getMessage());
		   	IsSuccess=false;
		}
	}
}

//System.out.println(&quot;insertResult &quot; + bsh.shared.insertResult);
stmt.close();
conn.close();
System.out.println(&quot;--------------------\nInsert Phase Completed\n--------------------\n&quot;);</stringProp>
            <stringProp name="BeanShellSampler.filename"></stringProp>
            <stringProp name="BeanShellSampler.parameters"></stringProp>
            <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
          </BeanShellSampler>
          <hashTree/>
          <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="updateTestCases" enabled="true">
            <stringProp name="BeanShellSampler.query">import java.sql.*;
import org.apache.jmeter.protocol.jdbc.config.DataSourceElement;
Random rand = new Random();
String line = &quot;&quot;;
String tableName = &quot;&quot;;
String sql = &quot;&quot;;
ArrayList exprCols;
ArrayList condCols;
colTypes = new ArrayList(bsh.shared.colTypes);

generateLineStart(){
	return ${SQL_UPDATE} + tableName + &quot; set &quot;;
}

getColName(String colType){
	ArrayList colName = new ArrayList();
	switch(colType){
		case ${VINDEX}:
			if(bsh.shared.vindex.get(tableName).size() != 0){
				colName.add(bsh.shared.vindex.get(tableName).get(rand.nextInt(bsh.shared.vindex.get(tableName).size())));
			}
			break;
		case ${SEC_INDEX}:
			secIndex = bsh.shared.tableMetaData.get(tableName).get(${SEC_INDEX});
			if(secIndex.size() != 0){
				colName.add(secIndex.get(rand.nextInt(secIndex.size())));
			}
			break;
		case ${NON_INDEX}:
			nonIndex = bsh.shared.tableMetaData.get(tableName).get(${NON_INDEX});
			if(nonIndex.size() != 0){
				colName.add(nonIndex.get(rand.nextInt(nonIndex.size())));
			}
			break;
		case ${SHARDINGKEY}:
			colName.add(bsh.shared.shardingKey.get(tableName));
			break;
		case ${PRIMARYKEY}:
			for(String pk: bsh.shared.tableMetaData.get(tableName).get(${PRIMARYKEY})){
				colName.add(pk);
			}
			break;
		case ${VINDEX_UNIQUE}:
			if(bsh.shared.vindexUnique.get(tableName).size() != 0){
				colName.add(bsh.shared.vindexUnique.get(tableName).get(rand.nextInt(bsh.shared.vindexUnique.get(tableName).size())));
			}
			break;
	}
	return colName;
}

getDataType(ArrayList colNames){
	dataTypes = new ArrayList();
	for(String colName: colNames){
		dataTypes.add(bsh.shared.tableMetaData.get(tableName).get(&quot;colDetails&quot;).get(colName).get(&quot;Type&quot;));
	}
	return dataTypes;
}


getIndexes(ArrayList colNames){
	indexes = new ArrayList();
	for(String colName: colNames){
		indexes.add(bsh.shared.colNameList.get(tableName).indexOf(colName));
	}
	return indexes;
}

constantExpression(ArrayList colNames, ArrayList dataTypes, ArrayList updatedRow){
	String expr = &quot;&quot;;
	String colName = &quot;&quot;;
	String dataType = &quot;&quot;;
	int index;
	ArrayList colNameList = bsh.shared.colNameList.get(tableName);
	for(int i=0; i&lt;colNames.size(); i++){
		colName = colNames.get(i);
		dataType = dataTypes.get(i);
		index = colNameList.indexOf(colName);
		switch(dataType){
			case &quot;BIGINT&quot;:
				long updatedValue = Long.parseLong(updatedRow.get(index)) + ${BIGINT_RANGE};
				updatedRow.set(index, updatedValue.toString());
				expr = expr + colName + ${EQUALS} + updatedValue + ${PARAMETER_SEPARATOR}; 
				break;
			case &quot;TINYINT&quot;:
				int updatedValue = Integer.parseInt(updatedRow.get(index)) + ${TINYINT_RANGE};
				updatedRow.set(index, updatedValue.toString());
				expr = expr + colName + ${EQUALS} + updatedValue + ${PARAMETER_SEPARATOR}; 
				break;
			case &quot;INT&quot;:
				int updatedValue = Integer.parseInt(updatedRow.get(index)) + ${INT_RANGE};
				updatedRow.set(index, updatedValue.toString());
				expr = expr + colName + ${EQUALS} + updatedValue + ${PARAMETER_SEPARATOR}; 
				break;
			case &quot;BIT&quot;:
				int updatedValue = Integer.parseInt(updatedRow.get(index)) + ${BIT_RANGE};
				updatedRow.set(index, updatedValue.toString());
				expr = expr + colName + ${EQUALS} + updatedValue + ${PARAMETER_SEPARATOR}; 
				break;
			case &quot;VARCHAR&quot;:
			case &quot;CHAR&quot;:
				String updatedString = updatedRow.get(index).concat(${PREFIX_STRING});
				updatedRow.set(index, updatedString);
				expr = expr + colName + ${EQUALS} + updatedString + ${PARAMETER_SEPARATOR}; 
				break;
			default:
				System.out.println(&quot;DATATYPE: &quot; + dataType + &quot; not supported for update query!&quot;);
		}
	}
	if(expr.length() &gt; 0){
		expr = expr.substring(0, expr.length() - ${PARAMETER_SEPARATOR}.length());
	}
	return expr;
}

createExpression(ArrayList colNames, ArrayList dataTypes, ArrayList updatedRow){
	String expr = &quot;&quot;;
	String colName = &quot;&quot;;
	String dataType = &quot;&quot;;
	int index;
	ArrayList colNameList = bsh.shared.colNameList.get(tableName);
	for(int i=0; i&lt;colNames.size(); i++){
		colName = colNames.get(i);
		dataType = dataTypes.get(i);
		index = colNameList.indexOf(colName);
		switch(dataType){
			case &quot;BIGINT&quot;:
				long updatedValue = Long.parseLong(updatedRow.get(index)) + ${BIGINT_RANGE};
				updatedRow.set(index, updatedValue.toString());
				expr = expr + colName + ${EQUALS} + colName + &quot;+&quot; + ${BIGINT_RANGE} + ${PARAMETER_SEPARATOR}; 
				break;
			case &quot;TINYINT&quot;:
				int updatedValue = Integer.parseInt(updatedRow.get(index)) + ${TINYINT_RANGE};
				updatedRow.set(index, updatedValue.toString());
				expr = expr + colName + ${EQUALS} + colName + &quot;+&quot; + ${TINYINT_RANGE} + ${PARAMETER_SEPARATOR}; 
				break;
			case &quot;INT&quot;:
				int updatedValue = Integer.parseInt(updatedRow.get(index)) + ${INT_RANGE};
				updatedRow.set(index, updatedValue.toString());
				expr = expr + colName + ${EQUALS} + colName + &quot;+&quot; + ${INT_RANGE} + ${PARAMETER_SEPARATOR}; 
				break;
			case &quot;BIT&quot;:
				int updatedValue = Integer.parseInt(updatedRow.get(index)) + ${BIT_RANGE};
				updatedRow.set(index, updatedValue.toString());
				expr = expr + colName + ${EQUALS} + colName + &quot;+&quot; + ${BIT_RANGE} + ${PARAMETER_SEPARATOR}; 
				break;
			case &quot;VARCHAR&quot;:
			case &quot;CHAR&quot;:
				updatedRow.set(index, updatedRow.get(index).concat(${PREFIX_STRING}));
				expr = expr + colName + ${EQUALS} + &quot;concat&quot; + ${BRACKET_OPEN} + colName + ${PARAMETER_SEPARATOR} + ${PREFIX_STRING} +${BRACKET_CLOSE} + ${PARAMETER_SEPARATOR}; 
				break;
			default:
				System.out.println(&quot;DATATYPE: &quot; + dataType + &quot; not supported for update query!&quot;);
		}
	}
	if(expr.length() &gt; 0){
		expr = expr.substring(0, expr.length() - ${PARAMETER_SEPARATOR}.length());
	}
	return expr;
}

generateExpression(String updateType, String colType, ArrayList updatedRow){
	ArrayList colNames = getColName(colType);
	if(colNames.isEmpty()){
		return &quot;&quot;;
	}
	ArrayList dataTypes = getDataType(colNames);
	String expression = &quot;&quot;;
	switch(updateType){
		case &quot;constant&quot;:
			expression = constantExpression(colNames, dataTypes, updatedRow);
			break;
		case &quot;expression&quot;:
			expression = createExpression(colNames, dataTypes, updatedRow);
			break;
		default :
			System.out.println(&quot;Not supported yet!&quot;);
	}
	return expression + ((expression.equals(&quot;&quot;)) ? &quot;&quot; : ${PARAMETER_SEPARATOR});
}

createCondition(ArrayList colNames, ArrayList indexes, ArrayList dataTypes, ArrayList currentRow){
	String colName = &quot;&quot;;
	String dataType = &quot;&quot;;
	int index; 
	String condition = &quot;&quot;;
	for(int i=0; i&lt;colNames.size(); i++){
		colName = colNames.get(i);
		dataType = dataTypes.get(i);
		index = indexes.get(i);
		switch(dataType){
			case &quot;BIGINT&quot;:
			case &quot;INT&quot;:
			case &quot;TINYINT&quot;:
			case &quot;BIT&quot;:
				condition = condition + colName + ${EQUALS} + currentRow.get(index) + ${PARAMETER_SEPARATOR};
				break;
			case &quot;VARCHAR&quot;:
			case &quot;CHAR&quot;:
			case &quot;DATETIME&quot;:
				condition = condition + colName + ${EQUALS} + ${SQL_QUOTE} + currentRow.get(index) + ${SQL_QUOTE} + ${PARAMETER_SEPARATOR};
				break;
			default:
				System.out.println(&quot;DATATYPE: &quot; + dataType + &quot; not supported for update query!&quot;);
		}
	}
	if(condition.length() &gt; 0){
		condition = condition.substring(0, condition.length() - ${PARAMETER_SEPARATOR}.length());
	}
	return condition;
}

generateCondition(String colType, ArrayList currentRow){
	ArrayList colNames = getColName(colType);
	if(colNames.isEmpty()){
		return &quot;&quot;;
	}
	ArrayList indexes = getIndexes(colNames);
	ArrayList dataTypes = getDataType(colNames);
	String condition = createCondition(colNames, indexes, dataTypes, currentRow);
	return condition + ((condition.equals(&quot;&quot;)) ? &quot;&quot; : ${PARAMETER_SEPARATOR});
}

line = vars.get(&quot;line&quot;);
String[] content = line.split(${TESTCASE_SEPARATOR});
String updateType = content[0];
exprCols = new ArrayList(Arrays.asList(content[1].split(${PARAMETER_SEPARATOR})));
condCols = new ArrayList(Arrays.asList(content[2].split(${PARAMETER_SEPARATOR})));
if(exprCols.isEmpty() || condCols.isEmpty()){
	continue;
}
String initial = &quot;&quot;;
String expression;
String condition;

Connection conn = DataSourceElement.getConnection(vars.get(&quot;MACHINE&quot;));
Statement stmt = conn.createStatement();
//System.out.println(&quot;old:&quot; + bsh.shared.insertResult);
try{
	for(String tN: bsh.shared.tableMetaData.keySet()){
		tableName = tN;
		for(int i=0; i&lt;${NUM_OF_TESTROWS}; i++){
			ArrayList currentRow = bsh.shared.insertResult.get(tableName).get(new ArrayList()).get(i);
			updatedRow = new ArrayList();
			updatedRow.addAll(currentRow);
			initial = generateLineStart();
			expression = &quot;&quot;;
			condition = &quot;&quot;;

			for(String colType: exprCols){
				if(colType.matches(${REGEX_WHITESPACE})){
					continue;
				}
				expression =  expression.concat(generateExpression(updateType, colType, updatedRow));
			}

			if(expression.equals(&quot;&quot;)){
				continue;
			}
			expression = expression.substring(0, expression.length() - 1) + ${SQL_WHERE_CLAUSE};

			for(String colType: condCols){
				condition = condition.concat(generateCondition(colType, currentRow));
			}
			if(condition.equals(&quot;&quot;)){
				continue;
			}
			condition = condition.substring(0, condition.length() - ${PARAMETER_SEPARATOR}.length());
			sql = initial + expression + condition; 
//			System.out.println(sql);
//			System.out.println(&quot;current: &quot; + currentRow + &quot;\nupdate: &quot; + updatedRow);
			try{
				stmt.executeUpdate(sql);
				bsh.shared.insertResult.get(tableName).get(new ArrayList()).set(i, updatedRow);
			}
			catch(Exception e){
				System.out.println(&quot;Testcase &quot; + line + &quot; failed. Check log for more info!&quot;);
				log.error(e.getMessage());
				if(e.getMessage().toLowerCase().contains(&quot;unsupported&quot;)){
					System.out.println(&quot;Query Unsupported!&quot;);
					break;
				}
			}
		}
	}

}
catch(Exception e){
	System.out.println(e);
}
finally{
	stmt.close();
	conn.close();
}
//System.out.println(&quot;new:&quot; + bsh.shared.insertResult);
</stringProp>
            <stringProp name="BeanShellSampler.filename"></stringProp>
            <stringProp name="BeanShellSampler.parameters"></stringProp>
            <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
          </BeanShellSampler>
          <hashTree/>
          <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="selectNCompare" enabled="true">
            <stringProp name="BeanShellSampler.query">import java.sql.*;
import java.math.BigInteger;
import org.apache.jmeter.protocol.jdbc.config.DataSourceElement;
import java.sql.Timestamp;

String tableName = &quot;&quot;;
System.out.println(&quot;--------------------\nValidation Phase Start\n--------------------\n&quot;);
response = &quot;&quot;;

setResponse(){
    SampleResult.setResponseData(response);
}

/*
 * 
 */
processResultSet(ResultSet result, ArrayList returnCols, boolean isSecResult){
	ResultSetMetaData rsmd = result.getMetaData();
//	System.out.println(&quot;ReturnCols: &quot; + returnCols);
     int columnCount = rsmd.getColumnCount();
//	System.out.println(&quot;ColCount: &quot; + columnCount);
//	System.out.println(&quot;TableName &quot; + tableName);
        
     rows = new ArrayList();
     while(result.next()){
     	row = new ArrayList();
          int i=1;
          for(i=1; i&lt;=columnCount; i++){
          	row.add(null);
          }
          i=1;
        	boolean valid = true;
        	while(i&lt;=columnCount){
			String colName = rsmd.getColumnName(i).toLowerCase();
               if((result.getObject(i) == null) &amp;&amp; bsh.shared.tableMetaData.get(tableName).get(&quot;colDetails&quot;).get(colName).get(${IS_NULLABLE}).equals(&quot;NO&quot;)){
				System.out.println(&quot;not valid&quot;);
                    valid = false;
                    break;
                }
/*
 * DataType Specific processing
 * TIMESTAMP is returned in UTC from secondary store. So converted to IST
 */
			if(result.getObject(i) != null){
               	if(rsmd.getColumnTypeName(i).equals(&quot;TIMESTAMP&quot;) &amp;&amp; isSecResult){
                    	Timestamp str = new Timestamp((Timestamp.valueOf(result.getString(i))).getTime() + ${UTC_TO_IST});
                    	row.set(returnCols.indexOf(colName), str.toString());
                   	}
                    else{
                        	row.set(returnCols.indexOf(colName), result.getString(i));
                    }
			}
               else{
               	row.set(returnCols.indexOf(colName), null);
               }
               i++;
		}
          if(valid){
          	rows.add(row);
          }
	}
     return rows;
}

compareDatetime(String one, String two){
	boolean same = true;
//	System.out.println(&quot;Hi &quot; + one + two);
	if(one == null){
		if(Objects.equals(one, two)){
		}
		else{
			same = false;
		}
	}
	else{	
		long date1 = Timestamp.valueOf(one).getTime();
	     long date2 = Timestamp.valueOf(two).getTime();
	     long diff = date1 - date2;
	     if(diff &lt; ${DATETIME_ACCU} &amp;&amp; diff &gt; -${DATETIME_ACCU}){
	     }
	     else{
	     	same=false;
	     }
	}
     return same;
}

compareRow(ArrayList rowOne, ArrayList rowTwo, ArrayList compareColumnList){
	typeList = new ArrayList();
    	for(String colName: compareColumnList){
     	typeList.add(bsh.shared.tableMetaData.get(tableName).get(&quot;colDetails&quot;).get(colName).get(&quot;Type&quot;));
    	}
    	if(typeList.size() == 0){
     	for(String colName: bsh.shared.colNameList.get(tableName)){
          	typeList.add(bsh.shared.tableMetaData.get(tableName).get(&quot;colDetails&quot;).get(colName).get(&quot;Type&quot;));
        	}       
    	}
	
	boolean same=true;

     for(int i=0; i&lt;rowOne.size(); i++){
		//add any type specific code here using typeList
          boolean compare = true;
          if(!(typeList.get(i).equals(&quot;DATETIME&quot;))){
          	compare = Objects.equals(rowOne.get(i), rowTwo.get(i));
		}
          else{
          	compare = compareDatetime(rowOne.get(i), rowTwo.get(i));
          }
          if(compare){
//			System.out.println(&quot;YES &quot; + &quot;ValueOne: &quot; + rowOne.get(i) + &quot; ValueTwo: &quot; + rowTwo.get(i));
          	continue;
          }
          else{
          	same = false;
//            	System.out.println(&quot;NO &quot; + &quot;ValueOne: &quot; + rowOne.get(i) + &quot; ValueTwo: &quot; + rowTwo.get(i));
          	break;
          }
	}
	return same;
}

compareResults(ArrayList rowsOne, ArrayList rowsTwo, boolean insertResultAsSecondArg, ArrayList compareColumnList){
    	colNameList = new ArrayList(bsh.shared.colNameList.get(tableName));
//  	System.out.println(&quot;RowOne: &quot; + rowsOne + &quot;\nRowTwo: &quot; + rowsTwo);
    	boolean status = true;
    	if(rowsOne.isEmpty()){
        	response = response.concat(&quot;COMPARING WITH EMPTY SET!\n&quot;);
        	System.out.println(&quot;COMPARING WITH EMPTY SET!&quot;);
    	}

	for(ArrayList rowOne: rowsOne){
     	boolean present=false;
        	for(ArrayList rowTwo: rowsTwo){
   		     temp = new ArrayList();
		     if(insertResultAsSecondArg){
		     	for(String colName: compareColumnList){
		          	temp.add(rowTwo.get(colNameList.indexOf(colName)));
		          }
			}
		     else{
		     	temp.addAll(rowTwo);
		     }
			boolean same = compareRow(rowOne, temp, compareColumnList);
			if(!same){
               	continue;
            	}
            	else{
               	response = response.concat(&quot;Matched! =&gt; Row: &quot; + rowOne + &quot;\n&quot;);
                	present=true;
                	break;
            	}
        }
        if(!present){
            response = response.concat(&quot;UNMATCHED! =&gt; Row: &quot; + rowOne + &quot;\n&quot;);
            status = false;
        }
    	}
     setResponse();
    	return status;
}

Connection txnl = DataSourceElement.getConnection(${TXNL});
//Connection sec = DataSourceElement.getConnection(${SECONDARY});
Connection sec = DataSourceElement.getConnection(${SECONDARY});
Statement stmtTxnl = txnl.createStatement();
Statement stmtSec = sec.createStatement();

ArrayList rowsTxnl;
ArrayList rowsSec;

String line = &quot;&quot;;
int count = 0;
results = new ArrayList();
br = new BufferedReader(new FileReader(${SELECT_FILE}));
while ((line = br.readLine()) != null){
	try{
     	String[] content = line.split(${TESTCASE_SEPARATOR});
        	tableName = content[0];
        	String query = content[1];
        	System.out.println(&quot;-----------&quot; + tableName + &quot;-----------\n&quot;);
        	System.out.println(query);
        
        	ResultSet resultTxnl = stmtTxnl.executeQuery(query);
        	ResultSet resultSec = stmtSec.executeQuery(query);
        	
		returnCols = bsh.shared.tableMetaData.get(tableName).get(&quot;ReturnColumns&quot;);
//      	System.out.println(&quot;ReturnColumns: &quot; + returnCols);

        	response = response.concat(&quot;For table: &quot; + tableName + &quot;\nQuery: &quot; + query +&quot;\n&quot;);
		
//		System.out.println(&quot;Processing txnl result&quot;);      
        	rowsTxnl = processResultSet(resultTxnl, returnCols, false);
//		System.out.println(&quot;ResultSet of txnl processed&quot;);
		
//		System.out.println(&quot;Processing sec result&quot;);     
        	rowsSec = processResultSet(resultSec, returnCols, true);
//		System.out.println(&quot;ResultSet of sec processed&quot;);

        	response = response.concat(&quot;Comparing master result and insert data\n&quot;);
        	compareColumnList = bsh.shared.tableMetaData.get(tableName).get(&quot;InsertColumnSequence&quot;);
		boolean one = compareResults(rowsTxnl, bsh.shared.insertResult.get(tableName).get(new ArrayList()), true, compareColumnList);
        	response = response.concat((one)?&quot;Master and Insert data matches!\n&quot; : &quot;Master and Insert data DO NOT match\n&quot;);

        	response = response.concat(&quot;-----------------------\nComparing master result and replica data\n&quot;);
		compareColumnList = returnCols;
        	boolean two = compareResults(rowsTxnl, rowsSec, false, compareColumnList);
        	response = response.concat((two)?&quot;Master and Replica data matches!\n&quot; : &quot;Master and Replica data DO NOT match\n&quot;);

        	response = response.concat((one &amp;&amp; two)?&quot;Query execution successfully!\n&quot; : &quot;Query failed!\n&quot;);
        	results.add(one &amp;&amp; two);
        	response = response.concat(&quot;-----------------------\n-----------------------\n&quot;);
        	setResponse();
        	count++;
	}
    	catch(Exception e){
        	System.out.println(&quot;Error: &quot; + e);
//      	e.printStackTrace();
        	IsSuccess = false;
        	count++;
        	results.add(false);
    	}
    	finally{
    		try{
    			bsh.shared.insertResult.get(tableName).put(new ArrayList(),rowsTxnl);
    		}
    		catch(Exception e){
    			System.out.println(e);
    		}
    	}
}
for(int i=0; i&lt;results.size();i++){
    IsSuccess = IsSuccess &amp;&amp; results.get(i);
    response = response.concat(&quot;Query &quot;+i+&quot;:&quot;+results.get(i)+&quot;\n&quot;);
    System.out.println(&quot;Query &quot;+i+&quot;:&quot;+results.get(i));
}
setResponse();
br.close();
stmtTxnl.close();
stmtSec.close();
sec.close();
txnl.close();
System.out.println(&quot;--------------------\nValidation Phase Completed\n--------------------\n&quot;);</stringProp>
            <stringProp name="BeanShellSampler.filename"></stringProp>
            <stringProp name="BeanShellSampler.parameters"></stringProp>
            <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
          </BeanShellSampler>
          <hashTree>
            <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="Constant Timer" enabled="false">
              <stringProp name="ConstantTimer.delay">10000</stringProp>
            </ConstantTimer>
            <hashTree/>
          </hashTree>
          <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="deleteUsingPreparedStmt" enabled="true">
            <stringProp name="BeanShellSampler.query">import java.sql.*;
import java.math.*;
import java.lang.Math.*;
import java.lang.Integer;
import java.lang.Long;
import org.apache.jmeter.protocol.jdbc.config.DataSourceElement;
System.out.println(&quot;--------------------\nDelete Phase\n--------------------\n&quot;);

String tableName = &quot;&quot;;
PreparedStatement stmt = null;
String sql = null;

colListIndex = new ArrayList();
dataTypeList = new ArrayList();

generateColList(){
	colList = new HashSet();
	colList.add(tableMetaData.get(tableName).get(${SHARDINGKEY}));
	colList.addAll(tableMetaData.get(tableName).get(${PRIMARYKEY}));
	return colList;
}

prepareStmtSkeleton(ArrayList colList){
	String initial = &quot;delete from &quot;+ tableName + &quot; where &quot;;
	String params = &quot;&quot;;
	
	for(int i=0; i&lt;colList.size(); i++){
		params = params + colList.get(i) + &quot;=? and &quot;; 
	}
	
	params = params.substring(0, params.length()-5);

	return initial + params;
}

setData(ArrayList row, String dataType, int index, int place){
	/*
	 * Indexing for place in PreparedStatement starts from 1. Thus place++
	 */
	place++;
	switch(dataType){
     	case &quot;BIGINT&quot;:
     		stmt.setLong(place, Long.parseLong(row.get(index)));
        		break;
		case &quot;INT&quot;:
        	case &quot;BIT&quot;:
        	case &quot;TINYINT&quot;:
        		stmt.setInt(place, Integer.parseInt(row.get(index)));
        		break;
		case &quot;VARCHAR&quot;:
        	  	stmt.setString(place, row.get(index));
        		break;
        	case &quot;DATETIME&quot;:
            	stmt.setTimestamp(place, Timestamp.valueOf(row.get(index)));
        		break;
        	default:
        		System.out.println(&quot;Missing case for data type in setData function: &quot; + dataType);
    }
}


Connection conn = DataSourceElement.getConnection(vars.get(&quot;MACHINE&quot;));
tableMetaData = bsh.shared.tableMetaData;
try{
	for(String tN: tableMetaData.keySet()){
		tableName = tN;
		System.out.println(&quot;-----------&quot; + tableName + &quot;-----------&quot;);
		
		colList = new ArrayList(generateColList());
		if(colList.isEmpty()){
			continue;
		}
		sql = prepareStmtSkeleton(colList);	
		stmt=conn.prepareStatement(sql);
		System.out.println(sql);	
		colListIndex.clear();
		dataTypeList.clear();
		
		for(String colName: colList){
			colListIndex.add(bsh.shared.colNameList.get(tableName).indexOf(colName));
		}
		
		for(String colName: colList){
			dataTypeList.add(bsh.shared.tableMetaData.get(tableName).get(&quot;colDetails&quot;).get(colName).get(&quot;Type&quot;));
		}
//		System.out.println(&quot;Hi &quot; + colList + &quot;\n&quot; + dataTypeList + &quot;\n&quot; + colListIndex);
		for(Map.Entry entry: bsh.shared.insertResult.get(tableName).entrySet()){
			for(int i=0; i &lt; entry.getValue().size(); i++){
				int place=0;
				for(; place&lt;dataTypeList.size(); place++){
					setData(entry.getValue().get(i), dataTypeList.get(place), colListIndex.get(place), place);
				}
				try
				{
					stmt.executeUpdate();
				}
				catch (SQLException e){
					System.out.println(&quot;Error: &quot; + e.getMessage());
					IsSuccess=false;
				}
			}
		}
	}
}
catch(Exception e){
	IsSuccess=false;
	System.out.println(e);
}
System.out.println(&quot;--------------------\nDelete Phase Completed\n--------------------\n&quot;);	

stmt.close();
conn.close();</stringProp>
            <stringProp name="BeanShellSampler.filename"></stringProp>
            <stringProp name="BeanShellSampler.parameters"></stringProp>
            <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
          </BeanShellSampler>
          <hashTree/>
          <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="clearTxnl" enabled="false">
            <stringProp name="BeanShellSampler.query">import org.apache.jmeter.protocol.jdbc.config.DataSourceElement;
import java.sql.*;
Connection replica = DataSourceElement.getConnection(${TRANSACTIONAL});
Statement stmtReplica = replica.createStatement();

try{
	stmtReplica.executeUpdate(&quot;delete from shipment.runsheet&quot;);
	stmtReplica.executeUpdate(&quot;delete from shipment.shipment&quot;);
	stmtReplica.executeUpdate(&quot;delete from shipment.shipment_address&quot;);
	
}
catch(Exception e){
	System.out.println(e);
	IsSuccess = false;
}
stmtReplica.close();
replica.close();</stringProp>
            <stringProp name="BeanShellSampler.filename"></stringProp>
            <stringProp name="BeanShellSampler.parameters"></stringProp>
            <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
          </BeanShellSampler>
          <hashTree/>
          <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="clearArchival" enabled="true">
            <stringProp name="BeanShellSampler.query">import org.apache.jmeter.protocol.jdbc.config.DataSourceElement;
import java.sql.*;
Connection replica = DataSourceElement.getConnection(${SECONDARY});
Statement stmtReplica = replica.createStatement();

try{
//	ResultSet rs = stmtReplica.executeQuery(&quot;select * from shipment.runsheet where createdatetime=TO_DATE(&apos;&quot;+str+&quot;&apos;)&quot;);
/*	
 	ResultSet rs = stmtReplica.executeQuery(&quot;select * from shipment.runsheet&quot;);
	ResultSetMetaData rsmd = rs.getMetaData();
	int columnsNumber = rsmd.getColumnCount();
	
	while(rs.next()){
	for (int i = 1; i &lt;= columnsNumber; i++) {
		if (i &gt; 1) System.out.print(&quot;,  &quot;);
	        System.out.print(rsmd.getColumnName(i) + &quot; &quot; + rs.getString(i));
	    }
	    System.out.println(&quot;\n&quot;);
	}
*/
	stmtReplica.executeUpdate(&quot;delete from shipment.runsheet&quot;);
	stmtReplica.executeUpdate(&quot;delete from shipment.shipment&quot;);
	stmtReplica.executeUpdate(&quot;delete from shipment.shipment_address&quot;);
}
catch(Exception e){
	System.out.println(e);
	IsSuccess = false;
}
stmtReplica.close();
replica.close();</stringProp>
            <stringProp name="BeanShellSampler.filename"></stringProp>
            <stringProp name="BeanShellSampler.parameters"></stringProp>
            <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
          </BeanShellSampler>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
